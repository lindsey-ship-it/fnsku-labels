<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>FNSKU Labels – Vector Black & White</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/jsbarcode@3.11.6/dist/JsBarcode.all.min.js"></script>
  <!-- Convert SVG to vector PDF paths -->
  <script src="https://cdn.jsdelivr.net/npm/svg2pdf.js@2.2.1/dist/svg2pdf.min.js"></script>
  <style>
    /* keep SVG offscreen */
    #bcsvg{position:absolute; left:-9999px; top:-9999px; width:0; height:0;}
  </style>
</head>
<body>
  <!-- Bars-only SVG target (no text) so we get pure vector black bars -->
  <svg id="bcsvg"></svg>

  <script>
    // -------- Page & label geometry --------
    const A4 = { w: 210, h: 297 };           // mm
    const LABEL = { w: 47.8, h: 28.2 };      // mm (exact)
    const COLS = 4, ROWS = 10;

    // Gutters (spacing between labels)
    const H_GAP = 2.0;                       // mm between columns
    const V_GAP = 1.0;                       // mm between rows (keeps page < 297mm)

    const totalW = COLS * LABEL.w + (COLS - 1) * H_GAP;
    const totalH = ROWS * LABEL.h + (ROWS - 1) * V_GAP;
    const MARGIN_X = (A4.w - totalW) / 2;
    const MARGIN_Y = (A4.h - totalH) / 2;

    // -------- In-label layout --------
    const PAD = 2.8;            // mm inner padding (also provides quiet zones)
    const BARCODE_H = 12.5;     // mm bars height (slightly taller for scanning)

    // FNSKU line
    const FNSKU_FONT = 7;       // pt
    const GAP_AFTER_BARS = 0.8; // mm (bars → FNSKU; tight per your request)
    const GAP_AFTER_FNSKU = 4.5;// mm (FNSKU → text stack)

    // Text stack
    const SKU_FONT = 6.2;       // pt (bold)
    const BODY_FONT = 6.0;      // pt
    const LINE_GAP = 2.6;       // mm between lines

    // Footer
    const FOOTER_FONT = 6.5;    // pt
    const FOOTER_OFFSET = 2.0;  // mm up from label bottom
    const CLEAR_ABOVE_FOOTER = 3.5; // mm reserved above footer baseline
    const UP_SHIFT = 0.8;       // mm lift for the text stack

    // -------- Helpers --------
    const qp = new URL(location.href).searchParams;
    const getP = (k, d="") => (qp.get(k) ?? d);
    const decode = s => decodeURIComponent(s || "");

    async function run(){
      const sku     = getP("sku", "");
      const desc    = decode(getP("desc", ""));
      const country = getP("country", "");
      const fnsku   = getP("fnsku", "");

      const { jsPDF } = window.jspdf;
      const doc = new jsPDF({ unit: "mm", format: "a4", compress: true });
      doc.setFont("helvetica", "normal");

      // --- Build a vector barcode (SVG, bars only) ---
      let bcSVG = document.getElementById("bcsvg");
      bcSVG.innerHTML = ""; // reset
      if (fnsku) {
        // Pure black bars, no antialiasing greys
        JsBarcode(bcSVG, fnsku, {
          format: "code128",
          displayValue: false,
          margin: 0,
          width: 1.25,               // ≈ 0.33 mm X-dimension (excellent for scanners)
          height: Math.round(BARCODE_H * 3.78) // pixels, but svg2pdf scales via width/height
        });
        // Ensure strokes/fills are pure black
        bcSVG.querySelectorAll("*").forEach(el => {
          el.setAttribute("fill", "#000");
          el.setAttribute("stroke", "none");
        });
      }

      // --- Draw grid with gutters ---
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          const x0 = MARGIN_X + c * (LABEL.w + H_GAP);
          const y0 = MARGIN_Y + r * (LABEL.h + V_GAP);
          const cx = x0 + LABEL.w / 2;
          const maxTextW = LABEL.w - 2 * PAD;

          // 1) Bars (vector): convert the SVG to PDF paths at the placement rect
          if (fnsku) {
            const bx = x0 + PAD;
            const by = y0 + PAD;
            const bw = LABEL.w - 2 * PAD;
            const bh = BARCODE_H;
            // Render SVG vector content into the PDF at (bx,by) with given size
            window.svg2pdf(bcSVG, doc, { x: bx, y: by, width: bw, height: bh });
          }

          // 2) Footer (NEW / COUNTRY)
          const footerY = y0 + LABEL.h - FOOTER_OFFSET;
          doc.setFont("helvetica", "normal");
          doc.setFontSize(FOOTER_FONT);
          doc.text("NEW", x0 + PAD, footerY);
          if (country) doc.text(country.toUpperCase(), x0 + LABEL.w - PAD, footerY, { align: "right" });

          // 3) FNSKU text (crisp vector text)
          if (fnsku) {
            doc.setFont("helvetica", "normal");
            doc.setFontSize(FNSKU_FONT);
            const fnskuY = y0 + PAD + BARCODE_H + GAP_AFTER_BARS;
            doc.text(fnsku, cx, fnskuY, { align: "center", baseline: "top" });
          }

          // 4) Text stack: SKU (bold) then Description lines (centered)
          const parts = (desc || "").split(",");
          const desc1 = parts[0] ? parts[0].trim() : "";
          const desc2 = parts[1] ? parts[1].trim() : "";

          // nominal start
          let startY = y0 + PAD + BARCODE_H + GAP_AFTER_BARS + GAP_AFTER_FNSKU - UP_SHIFT;

          // count lines to keep above footer
          const stackCount = [sku ? "1" : null, desc1 || null, desc2 || null].filter(Boolean).length;
          const needed = (stackCount > 1) ? ((stackCount - 1) * LINE_GAP) : 0;
          const maxTopY = footerY - CLEAR_ABOVE_FOOTER - needed;
          if (startY > maxTopY) startY = Math.max(y0 + PAD + BARCODE_H + 0.8, maxTopY);

          // SKU (bold)
          let ty = startY;
          if (sku) {
            doc.setFont("helvetica", "bold");
            doc.setFontSize(SKU_FONT);
            // shrink SKU if needed to fit width (simple clamp)
            while (doc.getTextWidth(sku) > maxTextW && doc.getFontSize() > 5.4) {
              doc.setFontSize(doc.getFontSize() - 0.2);
            }
            doc.text(sku, cx, ty, { align: "center", baseline: "top" });
            ty += LINE_GAP;
          }

          // Description (up to 2 lines, centered)
          doc.setFont("helvetica", "normal");
          doc.setFontSize(BODY_FONT);
          const combined = [desc1, desc2].filter(Boolean).join(" ");
          let lines = doc.splitTextToSize(combined, maxTextW);
          if (lines.length > 2) {
            // shrink a bit; if still >2, ellipsize
            while (lines.length > 2 && doc.getFontSize() > 5.2) {
              doc.setFontSize(doc.getFontSize() - 0.2);
              lines = doc.splitTextToSize(combined, maxTextW);
            }
            if (lines.length > 2) {
              let last = lines[1];
              while (doc.getTextWidth(last + "…") > maxTextW && last.length) last = last.slice(0,-1);
              lines = [lines[0], last + "…"];
            }
          }
          for (const line of lines) {
            doc.text(line, cx, ty, { align: "center", baseline: "top" });
            ty += LINE_GAP;
          }

          // // Debug: outline label box
          // doc.setLineWidth(0.15); doc.rect(x0, y0, LABEL.w, LABEL.h);
        }
      }

      doc.save(`${(sku || "labels")}.pdf`);
    }

    run();
  </script>
</body>
</html>
